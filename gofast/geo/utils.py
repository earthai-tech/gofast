# -*- coding: utf-8 -*-
#   License: BSD-3-Clause
#   Author: LKouadio <etanoyau@gmail.com>

"""
Is a set of utilities that deal with geological rocks, strata and 
stratigraphic details for log construction. 
"""
from __future__ import annotations 

import warnings
import copy 
import numpy as np
import pandas as pd 
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt

from ..api.types import  Tuple,  Any, Optional, Union 
from ..api.types import  _F, ArrayLike, DataFrame 
from ..exceptions import  DepthError 
from ..api.property import Config 
from ..tools.coreutils import  convert_value_in, ellipsis2false
from ..tools.mathex import find_closest 
from ..tools.validator import  assert_xy_in  
from .gisutils import utm_to_ll, project_point_utm2ll # HAS_GDAL 
from .._gofastlog import gofastlog 
_logger = gofastlog().get_gofast_logger(__name__ )

__all__=["correct_data_location", "make_coords", "compute_azimuth", 
         "calculate_bearing", ]


def make_coords(
    reflong: Union[str, Tuple[float, float]],
    reflat: Union[str, Tuple[float, float]],
    nsites: int,
    *,
    r: float = 45.0,
    utm_zone: Optional[str] = None,
    step: Union[str, float] = '1km',
    order: str = '+',
    todms: bool = False,
    is_utm: bool = False,
    raise_warning: bool = True,
    **kwargs
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Generates a sequence of geographic coordinates (longitude and latitude). 
    
    Coordinates are generated by starting from a reference point, extending 
    over a specified number of sites with a defined step and direction.

    Parameters
    ----------
    reflong : Union[str, Tuple[float, float]]
        Reference longitude as a decimal degree or DMS string (DD:MM:SS), or a
        tuple indicating start and end longitudes for the coordinate generation.
    reflat : Union[str, Tuple[float, float]]
        Reference latitude as a decimal degree or DMS string (DD:MM:SS), or a
        tuple indicating start and end latitudes for the coordinate generation.
    nsites : int
        The number of sites (coordinates) to generate.
    r : float, optional
        Rotation angle in degrees from the north, used to define the direction
        of the generated line of sites. Default is 45 degrees.
    utm_zone : Optional[str], optional
        Specifies the UTM zone for conversion if coordinates are given in UTM format.
        Must be provided if is_utm is True.
    step : Union[str, float], optional
        Step size between sites, in meters ('m') or kilometers ('km').
        Default is '1km'.
    order : str, optional
        Order of the generated coordinates. '+' for ascending (default), 
        '-' for descending.
    todms : bool, optional
        If True, converts generated coordinates from decimal degrees to DMS 
        format. Default is False.
    is_utm : bool, optional
        If True, treats reflong and reflat as UTM coordinates (easting and northing).
        Default is False.
    raise_warning : bool, optional
        If True, raises a warning when necessary (
            e.g., GDAL not installed or improper coordinate system). Default is True.
    kwargs : dict
        Additional keyword arguments for internal functions 
        (e.g., conversion functions).

    Returns
    -------
    Tuple[np.ndarray, np.ndarray]
        Two numpy arrays containing the generated longitudes and latitudes,
        respectively, either in decimal degrees or DMS format.

    Examples
    --------
    Generate coordinates in decimal degrees with a step of 1km, 45-degree angle:
    >>> reflong, reflat = "110.485", "26.051"
    >>> nsites = 5
    >>> rlons, rlats = make_coords(reflong, reflat, nsites)
    >>> print(rlons)
    >>> print(rlats)

    Generate coordinates in DMS format with a step of 2km, 90-degree angle:
    >>> reflong, reflat = ("110:29:09", "26:03:05")
    >>> nsites = 3
    >>> rlons, rlats = make_coords(reflong, reflat, nsites, step='2km', r=90, todms=True)
    >>> print(rlons)
    >>> print(rlats)
    """
    step = _prepare_step(step)
    x0, y0 = (_convert_to_float(reflong), _convert_to_float(reflat)) if not is_utm else (reflong, reflat)
    if isinstance(reflong, Tuple):
        x0 = reflong[0]
    if isinstance(reflat, Tuple):
        y0 = reflat[0]

    x_end, y_end = _compute_endpoints(x0, y0, r, step, nsites)
    reflon_ar, reflat_ar = _generate_coordinates(x0, y0, x_end, y_end, nsites, order)

    # UTM conversion, warnings, and other processing can be added here
    if is_utm:
        reflon_ar, reflat_ar = _convert_utm_to_latlon(
            reflon_ar, reflat_ar, utm_zone, raise_warning, **kwargs)

    if todms:
        reflon_ar = np.array([_convert_dd_to_dms(lon) for lon in reflon_ar])
        reflat_ar = np.array([_convert_dd_to_dms(lat) for lat in reflat_ar])

    return reflon_ar, reflat_ar


def _convert_utm_to_latlon(
        reflon_ar: np.ndarray, reflat_ar: np.ndarray, utm_zone: str,
        raise_warning: bool = True, **kwargs) -> Tuple[np.ndarray, np.ndarray]:
    """
    Converts UTM coordinates to latitude and longitude.

    Parameters
    ----------
    reflon_ar : np.ndarray
        Array of UTM easting values.
    reflat_ar : np.ndarray
        Array of UTM northing values.
    utm_zone : str
        UTM zone for the coordinates, e.g., '10S' or '03N'.
    raise_warning : bool, optional
        If True, issues warnings about potential inaccuracies without GDAL.
    kwargs : dict
        Additional keyword arguments for the conversion function.

    Returns
    -------
    lat_ar : np.ndarray
        Array of latitude values in decimal degrees.
    lon_ar : np.ndarray
        Array of longitude values in decimal degrees.
    """
    if utm_zone is None:
        raise TypeError("Please provide your UTM zone e.g., '10S' or '03N'!")

    lat_ar = np.zeros_like(reflon_ar)
    lon_ar = np.zeros_like(reflat_ar)

    for kk, (lo, la) in enumerate(zip(reflon_ar, reflat_ar)):
        try:
            with warnings.catch_warnings():
                warnings.simplefilter('ignore')
                lat_ar[kk], lon_ar[kk] = project_point_utm2ll(
                    easting=la, northing=lo, utm_zone=utm_zone, **kwargs)
        except Exception as e:
            # Fallback or error handling here
            try:lat_ar[kk], lon_ar[kk] = utm_to_ll(
                23, northing=lo, easting=la, zone=utm_zone)
            except: raise ValueError(f"Error converting UTM to lat/lon: {e}")

    if raise_warning:
        warnings.warn("Conversion from UTM to lat/lon performed. Accuracy"
                      " depends on the underlying conversion method.")

    return lat_ar, lon_ar

def _convert_to_float(coord: str) -> float:
    """Converts coordinate string to float."""
    try:
        return float(coord)
    except ValueError:
        if ':' not in coord:
            raise ValueError(f'Could not convert value to float: {coord!r}')
        else:
            return _convert_dms_to_dd(coord)

def _convert_dms_to_dd(dms: str) -> float:
    """Converts coordinates from DMS (Degrees:Minutes:Seconds) to Decimal Degrees."""
    degrees, minutes, seconds = [float(part) for part in dms.split(':')]
    return degrees + minutes / 60 + seconds / 3600

def _convert_dd_to_dms(dd: float) -> str:
    """
    Converts coordinates from Decimal Degrees (DD) to Degrees, Minutes,
    Seconds (DMS) format.

    Parameters
    ----------
    dd : float
        The coordinate in decimal degrees to be converted.

    Returns
    -------
    str
        The coordinate in DMS format, formatted as "D:M:S".

    Example
    -------
    >>> _convert_dd_to_dms(110.4875)
    '110:29:15'
    """
    # Separate the decimal degrees into degrees, minutes, and remaining decimal minutes
    degrees = int(dd)
    minutes_decimal = abs(dd - degrees) * 60
    minutes = int(minutes_decimal)
    seconds = int((minutes_decimal - minutes) * 60)

    # Format the DMS string and return
    dms = f"{degrees}:{minutes:02d}:{seconds:02d}"
    return dms

def _prepare_step(step: Union[str, float]) -> float:
    """Prepares the step value, converting it to meters if necessary."""
    step = str(step).lower()
    if 'km' in step:  # Convert km to meters
        return float(step.replace('km', '')) * 1000
    elif 'm' in step:  # Assume meters if 'm' is specified
        return float(step.replace('m', ''))
    return float(step)

def _compute_endpoints(x0: float, y0: float, r: float, step: float, nsites: int
                       ) -> Tuple[float, float]:
    """Computes the endpoint coordinates based on the starting point, rotation 
    angle, step, and number of sites."""
    x_end = x0 + (np.sin(np.deg2rad(r)) * step * nsites) / (364000 * 0.3048)
    y_end = y0 + (np.cos(np.deg2rad(r)) * step * nsites) / (288200 * 0.3048)
    return x_end, y_end

def _generate_coordinates(x0: float, y0: float, x_end: float, y_end: float, 
                          nsites: int, order: str) -> Tuple[np.ndarray, np.ndarray]:
    """Generates linearly spaced coordinates between start and end points."""
    reflon_ar = np.linspace(x0, x_end, nsites)
    reflat_ar = np.linspace(y0, y_end, nsites)
    if order == '-':
        return reflon_ar[::-1], reflat_ar[::-1]
    return reflon_ar, reflat_ar


def correct_data_location(
    ydata: ArrayLike,
    xdata: Optional[ArrayLike] = None,
    func: Optional[_F[[Any], Any]] = None,
    column_selector: Optional[int|str] = 0,
    show: bool = False,
    return_fit_values: bool = False,
    **kwargs
) -> Tuple[ArrayLike, ArrayLike] | Tuple[ArrayLike, ArrayLike, ArrayLike]:
    """
    Corrects the location or position of data based on a given model function
    and returns the corrected data along with model parameters and optionally
    the covariance of these parameters.

    Parameters
    ----------
    ydata : ArrayLike
        The dependent data, a length M array - nominally `f(xdata, ...)`.
    xdata : ArrayLike, optional
        The independent variable where the data is measured. It should usually
        be an M-length sequence or an (k, M)-shaped array for functions with
        k predictors, but can be any object. If None, `xdata` is generated
        using the length of `ydata`.
    func : callable, optional
        The model function, `f(x, ...)`, where `x` is the first argument and
        additional parameters are fitted. The default `func` is a linear
        function, `f(x) = ax + b`. Users are encouraged to define their own
        function for better fitting.
    column_selector : int or str, optional
        Specifies the column to use from `ydata` if it is a DataFrame. Can be
        an integer index or a column name.
    show : bool, optional
        If True, displays a quick visualization of the original and fitted
        data.
    return_fit_values : bool, optional
        If True, returns the optimized and covariance matrix of the fitted 
        parameters in addition to the corrected data and parameters.
    kwargs : dict
        Additional keyword arguments passed to `scipy.optimize.curve_fit`.

    Returns
    -------
    ydata_corrected : np.ndarray
        The corrected dependent data.
    popt : np.ndarray
        Optimal values for the parameters minimizing the squared residuals.
    pcov : np.ndarray, optional
        The estimated covariance of popt, returned if `return_cov` is True.

    Examples
    --------
    >>> from scipy.optimize import curve_fit
    >>> from gofast.geo.utils import correct_data_location
    >>> import pandas as pd
    >>> df = pd.read_excel('data/erp/l10_gbalo.xlsx')
    >>> # Correcting northing coordinates from easting data
    >>> northing_corrected, popt, pcov = correct_data_location(
            ydata=df['northing'],
            xdata=df['easting'],
            show=True
        )
    >>> print(len(df['northing']), len(northing_corrected))
    >>> print(popt)  # Should print the slope and intercept by default
    """

    def default_func(x, a, b):
        """Linear model function: f(x) = ax + b."""
        return a * x + b

    # Set default function if none provided or validate provided function
    if func is None or str(func).lower() in ('none', 'linear'):
        func = default_func
    elif not callable(func):
        raise TypeError(f'`func` argument must be callable, got {type(func).__name__!r}')

    if isinstance(ydata, pd.DataFrame):
        if isinstance(column_selector, str):
            if column_selector not in ydata.columns:
                raise ValueError(f'Column {column_selector!r} not found '
                                 'in DataFrame columns.')
            ydata = ydata[column_selector]
        else:
            ydata = ydata.iloc[:, column_selector]

    ydata = np.asarray(ydata)

    if xdata is None:
        xdata = np.arange(len(ydata))
    else:
        xdata = np.asarray(xdata)

    if len(xdata) != len(ydata):
        raise ValueError("xdata and ydata must have the same length.")

    popt, pcov = curve_fit(func, xdata, ydata, **kwargs)

    ydata_corrected = func(xdata, *popt)

    if show:
        plt.figure(figsize=(10, 6))
        plt.plot(xdata, ydata, 'b-', label='Original Data')
        plt.plot(xdata, ydata_corrected, 'r--',
                 label=f'Fitted: a={popt[0]:.3f}, b={popt[1]:.3f}')
        plt.title('Data Correction Visualization')
        plt.xlabel('X Data')
        plt.ylabel('Y Data')
        plt.legend()
        plt.show()

    return (ydata_corrected, popt, pcov) if return_fit_values else ydata_corrected 

def compute_azimuth(
    xlon: Union[str, ArrayLike], 
    ylat: Union[str, ArrayLike], 
    *, 
    data: Optional[DataFrame] = None, 
    utm_zone: Optional[str] = None, 
    projection: str = 'll', 
    isdeg: bool = True, 
    mode: str = 'soft', 
    extrapolate: bool = ...,
    view: bool = ...
) -> np.ndarray:
    """
    Computes azimuth between consecutive points given longitude and latitude 
    (or easting and northing) coordinates.

    Parameters
    ----------
    xlon : str or ArrayLike
        Longitudes or eastings of the points. If a string is provided, `data` must
        also be provided and should contain this column.
    ylat : str or ArrayLike
        Latitudes or northings of the points. If a string is provided, `data` must
        also be provided and should contain this column.
    data : DataFrame, optional
        DataFrame containing the `xlon` and `ylat` columns if `xlon` and `ylat`
        are provided as string names.
    utm_zone : str, optional
        UTM zone of the coordinates, necessary if projection is 'utm'. Should be 
        in the format '##N' or '##S'.
    projection : str, default 'll'
        Specifies the coordinate system of the input data ('utm' or 'll' for 
        longitude-latitude).
    isdeg : bool, default True
        If True, coordinates are assumed to be in degrees. Set to False if 
        coordinates are in radians.
    mode : str, default 'soft'
        If 'soft', projection type is automatically detected. If 'strict', 
        projection must be explicitly set.
    extrapolate : bool, default False
        If True, extrapolates the first azimuth to match the size of input 
        coordinates array.
    view : bool, default False
        If True, displays a plot of the computed azimuths.

    Returns
    -------
    azim : np.ndarray
        Array of computed azimuths between consecutive points.

    Examples
    --------
    >>> import pandas as pd
    >>> from gofast.geo.utils import compute_azimuth
    >>> # Example DataFrame
    >>> data = pd.DataFrame({
    ...     'longitude': [30, 31, 32],
    ...     'latitude': [10, 11, 12]
    ... })
    >>> compute_azimuth('longitude', 'latitude', data=data)
    array([45., 45.])

    """
    from .site import Location 
    # Handle ellipsis for extrapolate and view if not explicitly passed
    extrapolate, view = ellipsis2false(extrapolate, view)

    # Validate and extract xlon and ylat from data if necessary
    xlon, ylat = assert_xy_in(xlon, ylat, data=data)

    # Auto-detect projection if mode is 'soft'
    if mode == 'soft' and projection == 'll' and (xlon.max() > 180. or ylat.max() > 90.):
        projection = 'utm'
        if not utm_zone:
            raise ValueError("UTM zone must be specified for UTM projection.")

    # Convert UTM to lat-lon if necessary
    if projection == 'utm':
        if utm_zone is None:
            raise ValueError("utm_zone cannot be None when projection is UTM.")
        ylat, xlon = Location.to_latlon(xlon, ylat, utm_zone=utm_zone)

    # Ensure there are at least two points to calculate azimuth
    if len(xlon) < 2 or len(ylat) < 2:
        raise ValueError("At least two points are required to compute azimuth.")

    # Convert degrees to radians if necessary
    if isdeg:
        xlon = np.deg2rad(xlon)
        ylat = np.deg2rad(ylat)

    # Compute azimuth
    azim = np.arctan2(np.sin(xlon[1:] - xlon[:-1]) * np.cos(ylat[1:]),
                      np.cos(ylat[:-1]) * np.sin(ylat[1:]) - 
                      np.sin(ylat[:-1]) * np.cos(ylat[1:]) * np.cos(xlon[1:] - xlon[:-1]))
    azim = np.rad2deg(azim)
    azim = np.mod(azim, 360)  # Normalize to 0-360 degrees

    if extrapolate:
        # Extrapolate first azimuth
        azim = np.insert(azim, 0, azim[0])

    if view:
        plt.plot(azim, label='Azimuth')
        plt.xlabel('Point Index')
        plt.ylabel('Azimuth (degrees)')
        plt.legend()
        plt.show()

    return azim


def calculate_bearing(
    latlon1: Tuple[float, float], 
    latlon2: Tuple[float, float], 
    to_deg: bool = True
    ) -> float:
    """
    Calculates the bearing from one geographic location to another.

    The bearing is the compass direction to go from the starting point to the
    destination. It is defined as the angle measured in degrees clockwise from
    the north direction.

    The formula for calculating the bearing (\(\beta\)) between two points is given by:

    .. math::
        \beta = \arctan2(\sin(\Delta\lambda) \cdot \cos(\phi_2),
                         \cos(\phi_1) \cdot \sin(\phi_2) - \sin(\phi_1) \cdot \cos(\phi_2) \cdot \cos(\Delta\lambda))

    where:
        - \(\phi_1, \lambda_1\) are the latitude and longitude of the first 
          point (in radians),
        - \(\phi_2, \lambda_2\) are the latitude and longitude of the second
          point (in radians),
        - \(\Delta\lambda = \lambda_2 - \lambda_1\).

    Parameters
    ----------
    latlon1 : Tuple[float, float]
        The latitude and longitude of the first point in degrees (lat1, lon1).
    latlon2 : Tuple[float, float]
        The latitude and longitude of the second point in degrees (lat2, lon2).
    to_deg : bool, default True
        If True, converts the bearing result from radians to degrees.

    Returns
    -------
    bearing : float
        The calculated bearing in degrees if `to_deg` is True, otherwise in radians.

    Examples
    --------
    >>> calculate_bearing((28.41196763902007, 109.3328724432221),
                          (28.38756530909265, 109.36931920880758))
    127.26739270447973

    """
    lat1, lon1 = np.deg2rad(latlon1)
    lat2, lon2 = np.deg2rad(latlon2)

    delta_lon = lon2 - lon1

    x = np.sin(delta_lon) * np.cos(lat2)
    y = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(delta_lon)

    bearing = np.arctan2(x, y)

    if to_deg:
        bearing = np.degrees(bearing)
        bearing = (bearing + 360) % 360  # Normalize to 0-360 degrees

    return bearing

def find_similar_structures(
        *resistivities,  return_values: bool=...):
    """
    Find similar geological structures from electrical rock properties 
    stored in configure data. 
    
    Parameters 
    ------------
    resistivities: float 
       Array of geological rocks resistivities 
       
    return_values: bool, default=False, 
       return the closest resistivities of the close structures with 
       similar resistivities. 
       
    Returns 
    --------
    structures , str_res: list 
      List of similar structures that fits each resistivities. 
      returns also the closest resistivities if `return_values` is set 
      to ``True``.
    
    Examples
    ---------
    >>> from watex.utils.geotools import find_similar_structures
    >>> find_similar_structures (2 , 10, 100 , return_values =True)
    Out[206]: 
    (['sedimentary rocks', 'metamorphic rocks', 'clay'], [1.0, 10.0, 100.0])
    """
    if return_values is ...: 
        return_values =False 
    
    def get_single_structure ( res): 
        """ get structure name and it correspoinding values """
        n, v = [], []
        for names, rows in zip ( stc_names, stc_values):
            # sort values 
            rs = sorted (rows)
            if rs[0] <= res and res <= rs[1]: 
            #if rows[0] <= res <= rows[1]: 
                n.append ( names ); v.append (rows )
                
        if len(n)==0: 
            return "*Struture not found", np.nan  
        
        v_values = np.array ( v , dtype = float ) 
        # find closest value 
        close_val  = find_closest ( v_values , res )
        close_index, _= np.where ( v_values ==close_val) 
        # take the first close values 
        close_index = close_index [0] if len(close_index ) >1 else close_index 
        close_name = str ( n[int (close_index )]) 
        # remove the / and take the first  structure 
        close_name = close_name.split("/")[0] if close_name.find(
            "/")>=0 else close_name 
        
        return close_name, close_val 
    
    #---------------------------
    # make array of names structures names and values 
    dict_conf =  Config().geo_rocks_properties 
    stc_values = np.array (list( dict_conf.values()))
    stc_names = np.array ( list(dict_conf.keys() ))

    try : 
        np.array (resistivities) .astype (float)
    except : 
        raise TypeError("Resistivities array expects numeric values."
                        f" Got {np.array (resistivities).dtype.name!r}") 
        
    structures = [] ;  str_res =[]
    for res in resistivities: 
        struct, value = get_single_structure(res )
        structures.append ( struct) ; str_res.append (float(value) )

    return ( structures , str_res ) if  return_values else structures 

def build_random_thickness(
    depth, / , 
    n_layers=None, 
    h0= 1 , 
    shuffle = True , 
    dirichlet_dist=False, 
    random_state= None, 
    unit ='m'
): 
    """ Generate a random thickness value for number of layers 
    in deeper. 
    
    Parameters 
    -----------
    depth: ArrayLike, float 
       Depth data. If ``float`` the number of layers `n_layers` must 
       be specified. Otherwise an error occurs. 
    n_layers: int, Optional 
       Number of layers that fit the samples in depth. If depth is passed 
       as an ArrayLike, `n_layers` is ignored instead. 
    h0: int, default='1m' 
      Thickness of the first layer. 
      
    shuffle: bool, default=True 
      Shuffle the random generated thicknesses. 

    dirichlet_dis: bool, default=False 
      Draw samples from the Dirichlet distribution. A Dirichlet-distributed 
      random variable can be seen as a multivariate generalization of a 
      Beta distribution. The Dirichlet distribution is a conjugate prior 
      of a multinomial distribution in Bayesian inference.
      
    random_state: int, array-like, BitGenerator, np.random.RandomState, \
         np.random.Generator, optional
      If int, array-like, or BitGenerator, seed for random number generator. 
      If np.random.RandomState or np.random.Generator, use as given.
      
    unit: str, default='m' 
      The reference unit for generated layer thicknesses. Default is 
      ``meters``
      
    Return 
    ------ 
    thickness: Arraylike of shape (n_layers, )
      ArrayLike of shape equals to the number of layers.
      
    Examples
    ---------
    >>> from gofast.geo.utils import build_random_thickness 
    >>> build_random_thickness (7, 10, random_state =42  )
    array([0.41865079, 0.31785714, 1.0234127 , 1.12420635, 0.51944444,
           0.92261905, 0.6202381 , 0.8218254 , 0.72103175, 1.225     ])
    >>> build_random_thickness (7, 10, random_state =42 , dirichlet_dist=True )
    array([1.31628992, 0.83342521, 1.16073915, 1.03137592, 0.79986286,
           0.8967135 , 0.97709521, 1.34502617, 1.01632075, 0.62315132])
    """

    if hasattr (depth , '__array__'): 
        max_depth = max( depth )
        n_layers = len(depth )
        
    else: 
        try: 
            max_depth = float( depth )
        except: 
            raise DepthError("Depth must be a numeric or arraylike of float."
                             f" Got {type (depth).__name__!r}")

    if n_layers is None: 
        raise DepthError ("'n_layers' is needed when depth is not an arraylike.")

    layer0 = copy.deepcopy(h0)

    try: 
        h0= convert_value_in (h0 , unit=unit)
    except : 
        raise TypeError(f"Invalid thickness {layer0}. The thickness for each"
                        f" stratum should be numeric.Got {type(layer0).__name__!r}")

    thickness = np.linspace  (h0 , max_depth, n_layers) 
    thickness /= max_depth 
    # add remain data value to depth. 
    if  round ( max_depth - thickness.sum(), 2)!=0: 
        
        thickness +=  np.linspace (h0, abs (max_depth - thickness.sum()),
                                   n_layers )/thickness.sum()
    if dirichlet_dist: 
        if random_state: 
            np.random.seed (random_state )
        if n_layers < 32: 
            thickness= np.random.dirichlet (
                np.ones ( n_layers), size =n_layers) 
            thickness= np.sum (thickness, axis = 0 )
        else: 
            thickness= np.random.dirichlet (thickness) 
            thickness *= max_depth  
    
    if shuffle: 
        ix = np.random.permutation (
            np.arange ( len(thickness)))
        thickness= thickness[ix ]
  
    return thickness 



